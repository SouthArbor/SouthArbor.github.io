{"meta":{"title":"S.Arbor的个人博客","subtitle":"","description":"","author":"S.Arbor","url":"http://localhost:4000","root":"/"},"pages":[{"title":"categories","date":"2019-11-30T06:23:51.000Z","updated":"2019-11-30T06:32:35.924Z","comments":false,"path":"categories/index-1.html","permalink":"http://localhost:4000/categories/index-1.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-11-29T02:13:21.000Z","updated":"2019-11-30T06:23:11.049Z","comments":false,"path":"categories/index.html","permalink":"http://localhost:4000/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-11-01T10:18:49.000Z","updated":"2020-11-01T10:18:49.912Z","comments":true,"path":"archives/index.html","permalink":"http://localhost:4000/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"同步和异步和单线程","slug":"同步和异步和单线程","date":"2022-08-20T05:23:47.609Z","updated":"2022-08-20T05:25:46.019Z","comments":true,"path":"archives/ca17a695.html","link":"","permalink":"http://localhost:4000/archives/ca17a695.html","excerpt":"","text":"同步和异步的区别是什么?分别举出一个同步和异步的例子同步会阻塞代码执行,而异步不会 alert是同步,setTimeOut是异步 一个关于setTimeOut的面试题123456789console.log(1)setTimeout(function()&#123; console.log(2)&#125;,0)console.log(3)setTimeout(function()&#123; console.log(4)&#125;,1000)console.log(5) 前端使用异步的场景有哪些 定时任务:setTimeout , setInverval 网络请求:ajax请求,动态&lt;img&gt;加载 事件绑定","categories":[{"name":"javascript学习笔记","slug":"javascript学习笔记","permalink":"http://localhost:4000/categories/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript学习笔记","slug":"javascript学习笔记","permalink":"http://localhost:4000/tags/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"子元素的伪类","slug":"子元素的伪类","date":"2020-10-06T12:29:46.000Z","updated":"2020-11-01T14:17:02.477Z","comments":true,"path":"archives/42f9dbe1.html","link":"","permalink":"http://localhost:4000/archives/42f9dbe1.html","excerpt":"","text":"子元素选择器 :first-child 选择第一个子元素 123p:first-chile&#123; background-color:yellow;&#125; :last-child 选择最后一个子元素 123p:last-child&#123; background-color:yellow;&#125; :nth-child 选择指定位置的子元素 该选择器后面可以指定一个参数，指定要选中的第几个子元素 even 表示偶数位置的子元素 odd 表示奇数位置的子元素 123p:nth-child(1)&#123; background-color:yellow;&#125; :first-of-type :last-of-type :nth-of-type 和:first-child这些非常类似，只不过child是在所有的子元素中排列，而type，是在当前类型的子元素中排列","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/categories/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/tags/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"属性选择器","slug":"属性选择器","date":"2020-10-05T10:59:21.000Z","updated":"2020-11-01T14:17:02.479Z","comments":true,"path":"archives/11ce754c.html","link":"","permalink":"http://localhost:4000/archives/11ce754c.html","excerpt":"","text":"title属性，这个属性可以给任何标签指定 ​ 当鼠标移入到元素上时，元素中的title属性的值将会作为提示文字显示 123456&lt;p title = \"hello\"&gt;我是一个段落&lt;/p&gt;&lt;p title = \"cllo\"&gt;我是一个段落&lt;/p&gt;&lt;p title = \"adas\"&gt;我是一个段落&lt;/p&gt;&lt;p title = \"abfac\"&gt;我是一个段落&lt;/p&gt;&lt;p title = \"abad\"&gt;我是一个段落&lt;/p&gt;&lt;p title = \"abc\"&gt;我是一个段落&lt;/p&gt; 属性选择器 作用：可以根据元素中的属性或属性值来选取指定元素 语法： [属性名] 选取含有指定属性的元素 [属性名=”属性值”] 选取含有指定属性值的元素 [属性名^=”属性值”] 选取属性值以指定内容开头的元素 [属性名$=”属性值”] 选取属性值以指定内容结尾的元素 [属性名*=”属性值”] 选取属性值包含指定内容的元素 为所有的有title属性的p元素，设置一个背景颜色为黄色 123p[title]&#123; background-color:yellow;&#125; 为title属性值是hello的元素设置一个背景颜色为黄色 123p[title = hello]&#123; background-color:yellow;&#125; 为title属性值以ab开头的元素设置一个背景颜色为黄色 123p[title^=\"ab\"]&#123; background-color:yellow;&#125; 为title属性值以c结尾的元素设置一个背景颜色为黄色 123p[title$=\"c\"]&#123; background-color:yellow;&#125; 为title属性值包含c的元素设置一个背景颜色为黄色 123p[title*=\"c\"]&#123; background-color:yellow;&#125;","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/categories/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/tags/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"伪元素","slug":"伪元素","date":"2020-10-04T09:12:58.653Z","updated":"2020-11-01T14:08:11.502Z","comments":true,"path":"archives/d9e029f6.html","link":"","permalink":"http://localhost:4000/archives/d9e029f6.html","excerpt":"","text":"伪元素给段落定义样式 首字母 :first-letter 1234p:first-letter&#123; color:red; font-size:20px;&#125; 首行 :first-line 123p:first-line&#123; background-color:yellow;&#125; 元素最前边的部分 :before 1234p:before&#123; content:\"我会出现在整个段落的最前边\"; color：red;&#125; 元素最后边的部分 :after 1234p:after&#123; content:\"我会出现在整个段落的最后边\"; color：orange;&#125; 使用伪元素来表示元素中的一些特殊的位置","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/categories/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/tags/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"伪类选择器","slug":"伪类选择器","date":"2020-10-04T08:32:04.826Z","updated":"2020-11-01T14:09:22.044Z","comments":true,"path":"archives/97dce093.html","link":"","permalink":"http://localhost:4000/archives/97dce093.html","excerpt":"","text":"伪类选择器给链接定义样式 有四个伪类可以让你根据访问者宇该链接的交互方式，将链接设置成4种不同的状态。 正常链接（没访问过的链接） a:link​ 123a:link&#123; color:yellowgreen;&#125; 访问过的链接 a:visited（只能定义字体颜色） 123a:visited&#123; color:red;&#125; 鼠标滑过的链接 a:hover 123a:hover&#123; color:skyblue;&#125; 正在点击的链接 a:active :hover和:active也可以为其他元素设置IE6中，不支持队超链接以外的元素设置:hover和:active其他 获取焦点 :focus 123456/* 文本框获取焦点以后，修改背景颜色为黄色*/input:focus&#123; background-color:yellow;&#125; 指定元素前 :before 制定元素后 :after 选中的元素 ::sekection 12345678910111213141516171819/* 为p标签中选中的内容使用样式 可以使用::selection为类 注意：这个伪类在火狐中需要采用另一种方式编写::-moz-selection*//* 兼容火狐的*/p::-moz-selection&#123; background-color:orange;&#125;/* 兼容大部分浏览器的*/p::selection&#123; background-color:orange;&#125;","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/categories/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/tags/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"子元素和后代选择器","slug":"子元素和后代选择器","date":"2020-10-02T10:42:13.919Z","updated":"2020-11-01T14:11:06.761Z","comments":true,"path":"archives/6b8e67f.html","link":"","permalink":"http://localhost:4000/archives/6b8e67f.html","excerpt":"","text":"子元素和后代选择器后代元素选择器- 作用：选中指定祖先元素的指定后代元素 - 语法：祖先元素 后代元素{}123div span&#123; color:green;&#125; 子元素选择器 作用：选中指定父元素的指定子元素 语法：父元素 &gt; 子元素{} 123div &gt; span&#123; background-color:yellow;&#125;","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/categories/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/tags/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"常用的选择器","slug":"常用的选择器","date":"2020-10-01T16:40:30.224Z","updated":"2020-11-01T14:09:55.696Z","comments":true,"path":"archives/828f135c.html","link":"","permalink":"http://localhost:4000/archives/828f135c.html","excerpt":"","text":"常用的选择器元素选择器 作用：通过元素选择器可以选择页面中的所有指定元素 语法：标签名{} 123p&#123; color:red;&#125; id选择器- 作用：通过元素的id属性值选中唯一的一个元素 - 语法：#id属性值{}123#p1&#123; font-size:20px;&#125; 类选择器 作用：通过元素的class属性值选中一组元素 语法：.class属性值{} 123.p2&#123; font-size:20px;&#125; 选择器分组(并集选择器) 作用：通过选择器分组可以同时选中多个选择器对应的元素 语法：选择器1，选择器2，选择器N{} 123#p1,.p2,h1&#123; background-color:yellow;&#125; 通配选择器 作用：选中页面中的所有元素 语法：*{} 123*&#123; font-size:20px;&#125; 复合选择器（并集选择器） 作用：可以选中同时满足多个选择器的元素 语法：选择器1选择器2选择器N{} 123orange.small&#123; font-size:20px;&#125;","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/categories/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/tags/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"css的语法","slug":"css的语法","date":"2020-09-20T05:57:56.249Z","updated":"2020-11-01T14:10:28.996Z","comments":true,"path":"archives/976a9ed6.html","link":"","permalink":"http://localhost:4000/archives/976a9ed6.html","excerpt":"","text":"css的语法： ​ 选择器 声明块 ​ 选择器: 通过选择器可以选择选中页面中指定的元素， ​ 并且将声明块中的样式应用到选择器对应的元素上 声明块： ​ 声明块中实际上就是一组一组的名值对结构， ​ 这一组一组的名值对我们称为声明， ​ 在这一个声明块中可以写多个声明，多个声明之间使用；隔开， ​ 声明的样式名和样式值之间使用：来连接","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/categories/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/tags/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"css简介","slug":"css简介","date":"2020-09-19T09:42:31.712Z","updated":"2020-11-01T14:10:13.451Z","comments":true,"path":"archives/86071c5b.html","link":"","permalink":"http://localhost:4000/archives/86071c5b.html","excerpt":"","text":"内联样式 ​ 可以将css样式编写到元素的style属性中 ​ 将样式直接编写到style属性中，这种样式我们称为内联样式 ​ 内联样式只对当前的元素中的内容起作用，内联样式不方便复用 ​ 内联样式属于结构与表现耦合，不方便后期的维护，不推荐使用 也可以将css样式编写到head中的style标签里 ​ 将样式表编写的style标签中，然后通过css选择器选中指定元素 ​ 然后可以同时为这些元素一起设置样式，这样可以使样式进一步的复用 ​ 将样式表编写到style标签中，也可以是表现和结构进一步分离它也是我们推荐的使用方式 还可以将样式表编写到外部的css文件中，然后通过link标签来将外部的css文件引入到当前页面中 这样外部文件中的css样式表将会应用到当前页面中。 将css样式同意编写到外部样式表中，完全是结构和表现分离，可以使样式表在不同的页面使用， 最大限度的使样式可以复用，将样式同意卸载样式表中，然后通过link标签引入，可以利用浏览器缓存 加快用户访问的速度体改了用户体验，所以在开发中我们最推荐使用的方式就是外部的css文件","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/categories/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://localhost:4000/tags/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"超链接","slug":"超链接","date":"2020-09-18T11:39:16.485Z","updated":"2020-11-01T14:15:21.236Z","comments":true,"path":"archives/59c34dbb.html","link":"","permalink":"http://localhost:4000/archives/59c34dbb.html","excerpt":"","text":"超链接 ​ &lt;a&gt;标签 ​ 使用超链接可以让我们从一个页面跳转到另一个页面 ​ 使用a标签来创建一个超链接 ​ 属性： ​ href：指向链接跳转的目标地址，可以写一个相对路径也可以写一个完整的地址 ​ 将地址链接设置为’#’，则点击超链接时，可以直接回到页面顶部 ​ html中有一个属性，每一个元素都可以设置，该属性可以作为标签的唯一标识 ​ 这个属性就是id，id属性在同一个页面中只能有一个不能重复 ​ 发送电子邮件的超链接，点击链接以后可以自动打开计算机中默认的右键客户端 ​ href=’mailto:邮件地址’ ​ 当点击这个超链接时，会默认打开计算机的默认电子邮件客户端，并且将收件人设置为mailto的默认地址 ​ target：：可以用来指定打开链接的位置 ​ 可选值： ​ _self，表示在当前窗口中打开（默认值） ​ _blank，在新的窗口打开链接 ​ 可以设置一个内联框架的name属性值，链接将会在指定的内联框架中打开 ​","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/categories/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/tags/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"内联框架","slug":"内联框架","date":"2020-09-18T11:17:37.374Z","updated":"2020-11-01T14:15:46.054Z","comments":true,"path":"archives/14a4c1f7.html","link":"","permalink":"http://localhost:4000/archives/14a4c1f7.html","excerpt":"","text":"内联框架 ​ 使用内联框架可以引入一个外部的页面 ​ 使用ifame来创建一个内联框架 ​ 属性： ​ src:只想一个外部网页的路径，可以使用相对路径 ​ width： ​ height： ​ name：可以为内联框架指定一个name属性 ​ 在现实开发中不推荐使用内联框架，因为内联框架中的内容不会被搜索引擎所检索","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/categories/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/tags/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"HTML的语法规范","slug":"HTML的语法规范","date":"2020-09-17T14:40:07.508Z","updated":"2020-11-01T14:14:29.543Z","comments":true,"path":"archives/c55c6939.html","link":"","permalink":"http://localhost:4000/archives/c55c6939.html","excerpt":"","text":"xHTML的语法规范 ​ 1.HTML中不区分大小写，但是我们一般都用小写 ​ 2.HTML中的注释不能嵌套 ​ 3.HTML标签接续结构完整，要么成对出现，要么自结束标签 ​ (浏览器尽最大的努力正确的解析页面，你所有的不符合语法规范的内容， ​ 浏览器都会为你自动修正，但是有些情况会修正错误) ​ 4.HTML标签可以嵌套，但是不能交叉嵌套 ​ 5.HTML标签中的属性必须有值，且值必须加引号（双引号单引号都可以）","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/categories/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/tags/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"meta标签","slug":"meta标签","date":"2020-09-17T13:01:00.299Z","updated":"2020-11-01T14:14:56.609Z","comments":true,"path":"archives/8fd588e7.html","link":"","permalink":"http://localhost:4000/archives/8fd588e7.html","excerpt":"","text":"meta标签​ 使用meta标签还可以用来设置网页的关键字 1&lt;meta name = 'keywords' content = 'HTML,JavaScript,前端,Java'&gt; ​ 还可以用来指定网页的描述 ​ 搜索引擎在检索页面时，会同时检索页面中的关键字和描述，但是这两个只不会影响页面在搜索引擎中的排名 1&lt;meta name = 'description' content = '发布h5、js等前端相关的信息'&gt; ​ 使用meta可以用来做请求的重定向 1&lt;meta http-equiv = 'refresh' content = '5;url = http://www.baidu.com'&gt;","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/categories/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/tags/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"图片的格式","slug":"图片的格式","date":"2020-09-17T12:55:15.786Z","updated":"2020-11-01T14:21:17.638Z","comments":true,"path":"archives/ca17a645.html","link":"","permalink":"http://localhost:4000/archives/ca17a645.html","excerpt":"","text":"图片的格式 ​ JPEG（JPG） - JPEG图片支持的颜射比较多，图片可以压缩，但是不支持透明 - 一般使用JPEG来保存照片等颜色丰富的图片GIF - GIF支持的颜色少，只支持简单的透明，支持动态图 - 图片颜色单一或者是动态图是可以使用gifPNG - PNG支持的颜色多，并且支持复杂的透明 - 可以显示颜色复杂的透明的图片图片的使用原则： ​ 效果不一致，使用效果好的 ​ 效果一致，使用小的","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/categories/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://localhost:4000/tags/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"储物问题","slug":"储物问题","date":"2020-05-07T03:54:01.955Z","updated":"2020-05-20T12:23:43.275Z","comments":true,"path":"archives/c5fe61cc.html","link":"","permalink":"http://localhost:4000/archives/c5fe61cc.html","excerpt":"","text":"有一个仓库，仓库里面可以放10个物品（将来可以扩展可以放N个物品），每个物品的重量分别如下（要考虑重量可能是其它100以内的任意数值）： * 物品1 重量是 51 公斤 * 物品2 重量是 80 公斤 * 物品3 重量是 1 公斤 * 物品4 重量是 28 公斤 * 物品5 重量是 55 公斤 * 物品6 重量是 1 公斤 * 物品7 重量是 75 公斤 * 物品8 重量是 2 公斤 * 物品9 重量是 1 公斤 * 物品10 重量是 89 公斤 A 每个储物格可以存储格可以承重100公斤，请问，最少需要几个储物格，每个储物格存储哪些编号的商品（为了简化，本题目不考虑体积，但是要考虑重量可能是其它100以内的任意数值），才能存储下这些物品。 B 难度提高！存放商品的时候，顺序不能打乱，不能回看商品重量，不能跳过某个商品（这个时候，你要思考，在这么苛刻的条件下，怎么解决该问题），完成需要最少需要储物格的程序编写。","categories":[],"tags":[]},{"title":"常用DOS命令","slug":"常用DOS命令","date":"2020-02-20T06:20:09.517Z","updated":"2020-05-20T12:23:43.276Z","comments":true,"path":"archives/bd258fdd.html","link":"","permalink":"http://localhost:4000/archives/bd258fdd.html","excerpt":"","text":"常用DOS命令切换盘符： 盘符名称: 进入文件夹 cd 文件夹名称 进入多空文件夹 cd 文件夹1\\文件夹2\\文件夹3 返回上一级 cd .. 直接返回跟路径 cd \\ 查看当前内容 dir 清屏 cls 退出 exit","categories":[],"tags":[]},{"title":"mysql事务","slug":"mysql事务","date":"2020-02-17T09:05:12.376Z","updated":"2020-05-20T12:30:00.331Z","comments":true,"path":"archives/3d3705e1.html","link":"","permalink":"http://localhost:4000/archives/3d3705e1.html","excerpt":"mysql事务mysql 中，事务其实是一个最小的不可课分割工作单元。事务能保证一个业务的完整性。 比如我们银行转账： a -&gt; -100 1update user set money = money - 100 where name = 'a'; b -&gt; +100 1update user set money = money + 100 where name = 'b';","text":"mysql事务mysql 中，事务其实是一个最小的不可课分割工作单元。事务能保证一个业务的完整性。 比如我们银行转账： a -&gt; -100 1update user set money = money - 100 where name = 'a'; b -&gt; +100 1update user set money = money + 100 where name = 'b'; – 实际程序中，如果只有一条语句执行成功，而另一条没有执行成功？ – 出现数据前后不一致。 12update user set money = money - 100 where name = 'a';update user set money = money + 100 where name = 'b'; – 多条 sql 语句，可能会有同时成功的要求，要么就同时失败。 MySQL 中如何控制事务？ mysql 默认是开启事务的。（自动提交） 查看自动提交是否开启 1select @@autocommit; autocommit 为 1即为自动提交； – 默认事务开启的作用是什么？ – 当我们去执行一个sql 语句的时候，效果会立即体现出来，且不能回演。 123456789create database bank;create table user( id int primary key, name varchar(20), miney int);insert into user values(1,'a',1000); – 事务回滚： 撤销sql 语句执行效果 rollback : 事务回滚 1rollback; – 当 默认事务 开启时（autocommit 为 1），rollback无效 解决办法： 设置mysql 自动提交为 false 1set autocommit = 0; – 此时就可以进行事务回滚了。 – 但相对的，当自动提交关闭时，执行的语句只是临时效果，没有发生在数据库里面，都是在一张的虚拟表中，真实的表，其实是没有执行这些语句的。 – 这时我们要想把刚刚执行的操作确实的提交到数据库中怎么办呢？ – 用 commit； 手动提交数据 1commit; 这时，刚刚执行的操作，都不可撤销了； 自动提交？@@autocommit = 1 手动提交？commit； 事务回滚？rollback； – 事务给我们提供了一个返回的机会 手动开启事务MYSQL 事务处理主要有两种方法：1、用 BEGIN, ROLLBACK, COMMIT来实现 BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 2、直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 对于一个MYSQL数据库，事务的开启与提交模式无非下面这两种情况： 若参数autocommit=0，事务则在用户本次对数据进行操作时自动开启，在用户执行commit命令时提交，用户本次对数据库开始进行操作到用户执行commit命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。总而言之，当前情况下事务的状态是自动开启手动提交。 若参数autocommit=1（系统默认值），事务的开启与提交又分为两种状态： ①手动开启手动提交：当用户执行start transaction命令时（事务初始化），一个事务开启，当用户执行commit命令时当前事务提交。从用户执行start transaction命令到用户执行commit命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。 ②自动开启自动提交：如果用户在当前情况下（参数autocommit=1）未执行start transaction命令而对数据库进行了操作，系统则默认用户对数据库的每一个操作为一个孤立的事务，也就是说用户每进行一次操作系都会即时提交或者即时回滚。这种情况下用户的每一个操作都是一个完整的事务周期。 事务的四大特征A 原子性 ： 事务是最小的单位，不可再分割 C 一致性 ： 事务要求，同一事务中的 sql 语句，必须要保证同时成功或者失败 I 隔离性 ： 事务1 和事务 2之间是具有隔离性的 D 持久性 ： 事务一旦结束（commit,rollback）,就不可以返回 总结： 事务开启： 修改默认提交 set autocommit = 0; begin; start transaction; 事务手动提交： commit; 事务手动回滚： rollback; 事务的隔离性 read uncimmitted; 读未提交的 read committed; 读已经提交的 repeatable read; 可以重复读 serializable; 串行化 read uncommitted如果有事务a，和事务b， a 事务对数据进行操作，在操作的过程中，事务没有被提交，但是 b 可以看见 a 操作的结果 – bank数据库 user表 12insert into user values(3,'小明',1000);insert into user values(4,'淘宝店',1000); 如何查看数据库的隔离级别？mysql 8.0 ： – 系统级别的 1select @@global.transaction_isolation; – 会话级别的 1select @@transaction_isolation; mysql 5.x ： – 系统级别的 1select @@global.tx_isolation; – 会话级别的 1select @@tx_isolation; 如何修改隔离级别1set global transaction isolation level read uncommitted; – 转账： 小明在淘宝店买鞋子：800 ​ 小明-&gt;成都 ATM ​ 淘宝店-&gt;广州 ATM 123start transaction;update user set money = money - 800 where name = '小明';update user set money = money + 800 where name = '淘宝店'; – 给淘宝店打电话，说你去查一下，是不是到账了 – 淘宝店在广州查账 1select * from user; – 发货 – 晚上请女朋友吃好吃的 – 1800 小明-&gt;成都 1rollback; – 淘宝店算账的时候发现钱不够 1select * fron user – 如果两个不同的地方，都在进行操作，事务a开启之后，他的数据可以被其他食物读取到 – 这样就会出现（脏读） – 脏读 ： 一个事务读到了另一个事务没有提交的数据，就叫做脏读。 – 实际开发是不允许脏读 出现的。 read committed;查看当前隔离级别 1select @@global.transaction_isolation; 修改隔离级别为 read committed 1set global transaction isolation level read committed; bank 数据库 user 表 小张： 银行的会计 12start transaction;select * from user; 小张出去上厕所去了。。。抽烟 小王： 123start transaction;insert into user values(5,'c',100);commit; – 小张上完厕所，抽完烟回来 1select avg(money) from user; – money 的平均值不是一千，变少了？ – 虽然我只能读到另一个事务提交的数据，但还是会出现问题 – 读取同一个表的数据，发现前后不一致 – 不可重复读现象： read committed repeatable read查看当前隔离级别 1select @@global.transaction_isolation; 修改隔离级别为 repeatable read 1set global transaction isolation level repeatable read; 在repeatable read 隔离级别下又会出现什么问题？– 张全蛋 - 成都 1start transaction; – 王尼玛 - 北京 1start transaction; – 张全蛋 - 成都 12insert into user values(6,'d',1000);commit; 这时即使张全蛋已经提交了，但王尼玛还是不能查到刚刚提交的记录。 – 王尼玛 - 北京 1insert into user values(6,'d',1000); ERROR 1062 (23000)：Duplicate entry ‘6’ for key ‘PRIMARY’ – 即使王尼玛现在查询表，还是没有6号的记录。 – 这种现象就叫做幻读！！ – 事务a和事务b，同时操作一张表，事务a提交的数据，也不能被事务b读到，就可以造成幻读 serializable 查看当前隔离级别 1select @@global.transaction_isolation; 修改隔离级别为 repeatable read 1set global transaction isolation level serializable; – 张全蛋 - 成都 1start transaction; – 王尼玛 - 北京 1start transaction; – 张全蛋 - 成都 12insert into user values(7,'赵铁柱',1000);commit; – 王尼玛 - 北京 这时王尼玛查询表发现7号已经插入表了 1select * from user; – 张全蛋 - 成都 12start transaction;insert into user values(8,'王小花',1000); 这时张全蛋会发现，他在操作8号的时候，sql语句被卡住了？ 进入等待状态。等待什么呢？ 等待王尼玛的事务提交。 – 当user 表被另一个事务操作的时候，其他事务里面的写操作，是不可以进行的 – 进入排队状态（串行化），直到王尼玛那边事务结束之后，张全蛋这个的吸入操作才会执行。（在没有等待超时的情况下。） 串行化的问题是，性能特差！！！ read uncommitted &gt; read committed &gt; repreatable read &gt; serializable; 隔离级别越高，性能越差 mysql默认隔离级别是 repeatable read","categories":[],"tags":[]},{"title":"MySQL连接查询","slug":"MySQL连接查询","date":"2020-02-17T06:19:05.134Z","updated":"2020-05-20T12:30:30.701Z","comments":true,"path":"archives/9e1390b6.html","link":"","permalink":"http://localhost:4000/archives/9e1390b6.html","excerpt":"MySQL连接查询SQL的四种连接查询内连接 inner join 或者 join 外连接 左连接 left join 或者 left outer join 右连接 rightt join 或者 right outer join 完全外连接 full join 或者 full outer join","text":"MySQL连接查询SQL的四种连接查询内连接 inner join 或者 join 外连接 左连接 left join 或者 left outer join 右连接 rightt join 或者 right outer join 完全外连接 full join 或者 full outer join – 创建两个表： – person 表 id, name, cardId 12345create table person( id int, name varchar(20), cardId int); – card 表 id, name 1234create table card( id int, name varchar(20)); 123456789insert into card values(1,'饭卡');insert into card values(2,'建行卡');insert into card values(3,'农行卡');insert into card values(4,'工商卡');insert into card values(5,'邮政卡');insert into person values(1,'张三',1);insert into person values(2,'李四',3);insert into person values(3,'王五',6); inner join 查询（内连接）1select * from person inner join card on person.cardId = card.id; – 内联查询，其实就是两张表中的数据，通过某个字段相对，查询出相关记录数据。 inner 可以省略 1select * from person inner join card on person.cardId = card.id; left join （左外连接）1select * from person left join card on person.cardId = card.id; – 左外连接，会把左边里面的所有数据取出来，而右边表中的数据，如果有相等的，就显示出来 – 如果没有，就补 NULL right join（右外连接）1select * from person right join card on person.cardId = card.id; – 右外连接，会把左边里面的所有数据取出来，而左边表中的数据，如果有相等的，就显示出来 – 如果没有，就补 NULL full join（全外连接）1select * from person full join card on person.cardId = card.id; – 因为MySQL不支持full join，所以这条语句在MySQL中运行会报错 – 可以用左外连接+右外连接 得到全外连接的结果 123select * from person left join card on person.cardId = card.idunionselect * from person right join card on person.cardId = card.id;","categories":[],"tags":[]},{"title":"C 中printf无法输出问题","slug":"C 中printf无法输出问题","date":"2020-02-16T07:27:44.377Z","updated":"2020-02-16T09:01:22.578Z","comments":true,"path":"archives/288d0f5b.html","link":"","permalink":"http://localhost:4000/archives/288d0f5b.html","excerpt":"","text":"C 中printf无法输出问题在c++编程过程中遇到printf()函数无法输出的问题，但是代码没有问题，使用puts()函数可以正常输出。 上网查了一下 原因为系统缓冲区问题。有三个解决办法： 1.添加换行符 printf(“XXXXXXX \\n”); 2.输出后手动刷新系统缓冲区 fflush(stdout); 3.预先设定无缓冲区 setvbuf(stdout, NULL, _IONBF, 0); 原文链接：https://blog.csdn.net/gengyiping18/article/details/102729331","categories":[{"name":"C语言","slug":"C语言","permalink":"http://localhost:4000/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://localhost:4000/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"mysql查询练习","slug":"mysql查询练习","date":"2020-02-13T05:15:43.817Z","updated":"2020-05-20T12:30:54.199Z","comments":true,"path":"archives/a08a31.html","link":"","permalink":"http://localhost:4000/archives/a08a31.html","excerpt":"mysql查询练习创建数据库创建查询练习数据库selecttext。 123create database selecttext;use selecttext;","text":"mysql查询练习创建数据库创建查询练习数据库selecttext。 123create database selecttext;use selecttext; 创建表学生表 student 学号 姓名 性别 出生年月生日 所在班级 1234567create table student( sno varchar(20) primary key, sname varchar(20) not null, ssex varchar(10) not null, sbirthday datetime, class vaichar(20)); 成绩表 score 学号 课程号 成绩 1234567create table score( sno varchar(20) primary key, cno varchar(20) not null, degree decimal, foreign key(cno) refenrence course(cno) foreign key(sno) refenrence student(sno)); 教师表 teacher 教师编号 教师名字 教师性别 出生年月日 职称 所在部门 12345678create table teacher( tno varchar(20) primary key, tname varchar(20) not null, tsex varchar(10) not null, tbirthday datetime， prof varchar(20), depart varchar(20) not null); 课程表 course 课程号 课程名称 教师编号 123456create table course( cno varchar(20) primary key, cname varchar(20), tno varchar(20), foreign key(tno) references teacher(tno)); 查询练习1到10查询student表的所有记录。1select * from student; 查询student表中所有记录的 sname、ssex和class列1select sname,ssex,class from student; 查询教师所有的单位级不重复的depart列 distinct : 排重 1select distinct depart from teacher; 查询score表中成绩在60 到80之间所有记录 between [条件] and [条件] : 设置查询区间 1select * from score where degree between 60 and 80; 直接使用运算符比较 1select * from score where degree &gt; 60 and degree &lt; 80; 查询score表中成绩为85,86或88的记录 表示或者关系的查询: in([条件]) 1select * from score where degree in(85,86,88); 查询student表中’95031’班或性别为‘女’的同学记录 or 表示或者 1select * from student where class = '95031' or ssex = '女'; 以class降序查询student表中的所有记录。 order by : 排序 降序 ： desc 1select * from student order by class desc; 升序(默认) : asc 默认就是升序排列，asc可以不写 1select * from student order by class asc; 1select * from student order by class; 以cno升序，degree降序查询score表中的所有记录。1select * from score order by cno asc,degree desc; 查询‘95031’班的学生人数。 统计：count() 1select count(*) from student where class = &apos;95031&apos;; 查询score表中的最高分的学生学号和课程号。（子查询或者排序）1select sno,cno from score where degree = (select max(degree) from score); 找到最高分 1select max(degree) from score; 找最高分的sno和cno 1select sno,cno from where degree = (select max(degree) from score); 利用排序的做法： limit [数字],[数字]： 第一个数字表示从多少开始，第二个数字表示查多少条 1select sno,cno from score order by degree desc limit 0,1; 分组计算平均成绩查询每门课的平均成绩 avg() : 计算平均值 查询某一门课的平均成绩 1select avg(degree) from score where cno = '3-105'; 如何一条语句查询每门课的平均成绩？ group by ：按组排列 1select avg(degree) from score where score group by cno; 分组条件与模糊查询查询score表中至少有两名学生选修的并以3开头的课程的平均分数 having ： 和where用法类似 like : 模糊查询 1234select cno,avg(degree) from score group by cno having count(cno)&gt;=2 and cno like '3%'; 查询范围的两种方式查询分数大于10，小于90的sno列。1select sno,degree from score where degree &gt; 70 and degree &lt; 90; 多表查询查询所有学生的sname 、cno 、 degree 列多表查询找多表中共同拥有的字段，即外键约束 12select sname,cno,degree from student,scorewhere student.sno = score.sno; 查询所有学生的sno、cname 和 defree 列12select sno,cname,degree from course,scorewhere course.cno = score.cno; 查询所有学生的sname、cname、和degree列三表连接查询 12select sname,cname,degree from student,course,score where student.sno = score.sno and score.cno = course.cno; 查询选修某课程的同学人数多于5人的教师姓名 group by 和 having 配合使用，实现先分组再执行having后条件 先在成绩表中筛选出选修人数多于5人的课程 1select cno from score group by having count(cno)&gt;5; 然后将得到的课程号作为条件，在课程表中查询教师编号 12select tno from course where cno in (select cno from score group by having count(cno)&gt;5;); 然后将得到的教师编号作为条件（套娃真好玩），在教师表中查询教师姓名 12select tname from teacher where tno in (select tno from course where cno in (select cno from score group by having count(cno)&gt;5); 子查询查询选修‘3-105’课程的成绩高于‘109’号同学的所有同学化繁为简 先在成绩表中查询109号同学‘3-105’课程的的成绩 1select degree from score where cno = '3-105' and sno = '109'; 然后将109号同学的成绩作为条件，在成绩表中查询选修了‘3-105’并且成绩高于109号的所有同学 12select * from score where degree &gt; (select degree from score where cno = '3-105' and sno = '109') and cno = '3-105'; 查询成绩高于学号为‘109’、课程号为‘3-105’的成绩的所有记录化繁为简 查询109号同学‘3-105’课程的的成绩 1select degree from score where cno = '3-105' and sno = '109'; 然后将得到的成绩作为条件，在成绩表中查询所有成绩高于“109号同学‘3-105’课程的的成绩”的所有记录 12select * from score where degree &gt; (select degree from score where cno = '3-105' and sno = '109'); 查询出“计算机系”教师所教课程的成绩表先在教师表中查询出“计算机系”的教师的教师编号tno 1select tno from teacher where depart = '计算机系'; 然后将得到的教师编号作为条件，在课程表中查询出课程号 12select cno from course where tno in (select tno from teacher where depart = '计算机系'); 然后讲得到的课程号作为条件，在成绩表中查询课程的对应的所有成绩 12select degree from score where cno in (select cno from course where tno in (select tno from teacher where depart = '计算机系')); 查询所有任课教师的tname和depart先在课程表中查出任课老师的tno 1select tno from course; 然后在教师表中查询教师的tname、depart 1select tname,depart from teacher where tno in (select tno from course); 查询‘男’教师及其所上的课程。先在教师表中找出‘男’教师的tno 1select tno from teacher where tsex = '男'; 然后将得到的tno作为条件，在课程表中找到‘男’教师所上的课程 1select * from course where tno in (select tno from teacher where tsex = '男'); 查询和‘李军’同性别的所有同学的sname1select sname from student where ssex = (select ssex from student where sname = '李军'); 查询和‘李军’同性别且同班的所有同学的sname1select sname from student where ssex = (select ssex from student where sname = '李军') and class = (select class from student where where sname = '李军'); 查询所有选修’计算机导论‘课程的’男‘同学的成绩表。 1select * from score where cno = (select cno from course where cname = '计算机导论') and sno in (select sno from student where ssex = '男'); 子查询加分组求平均分查询‘95031’班的每门课的平均分大问题分化为小问题 查询得到‘95031’班学生的学号 1select sno from student where class = '95031'; 用得到的学号作为查询成绩表的条件,加上group by cno按课程号分组 123select cno,avg(degree) from score where sno in (select sno from student where class = '95031') group by cno; 条件加分组筛选查询至少有2名男生的班号查询学生表中ssex为‘男‘的学生的班级，并将记录按班号分组，将男生数量大于1个的班号展示出来 1select class from student a where ssex = '男' group by class having count(*)&gt;1; max函数与子查询查询最高分同学的sno、cno、和degree列先查出最高成绩 1select max(degree) from score; 然后将其作为条件，查出最高分同学的sno、cno、和degree列 1select * from score where degree = (select max(degree) from score); year函数与带in关键字的子查询查询与学号为108、101的同学同年出生的所有学生的sno、sname、sbirthday列year() : 取出日期格式中的year 先得到两位同学的出生年份 1select year(sbirthday) from student where sno in (108,101); 然后将得到的年份作为条件，查询学生表中和两位同学同年出生的所有学生 1select * from student where year(sbirthday) in (select year(sbirthday) from student where sno in (108,101)); 多层嵌套子查询查询“张旭”教师任课的学生成绩首先在教师表中查询到“张旭”教师的教师编号 1select tno from teacher where tname = '张旭'; 然后将得到的教师编号作为条件，在课程表中查询张旭老师任课的课程的课程号 12select cno from course where tno = (select tno from teacher where tname = '张旭'); 然后将得到的课程号作为条件(???套娃警告!!!)，在成绩表中查询选修了这门课的学生的成绩 12select degree from score where cno in (select cno from course where tno = (select tno from teacher where tname = '张旭')); in表示或者关系查询‘95031’班和‘95033’班全体学生的记录1select * from student where class in ('95033','95031'); where 条件查询查询存在有85分以上成绩的课程cno1select distinct cno from score where degree&gt;85; union 和 not in 的使用查询‘计算机系’与‘电子工程系’不同职称的教师的tname和prof首先查询出‘计算机系’和’电子工程系‘各自拥有的职称 123select prof from teacher where depart = '计算机系';select prof from teacher where depart = '电子工程系'; 然后将得到的‘计算机系’职称作为条件，查询出‘电子工程系’没有的职称 not in ： 不在，不被包含 1select * from teacher where depart = '电子工程系' and prof not in (select prof from teacher where depart = '计算机系'); 同法，得到‘电子工程系’职称中，‘计算机系’没有的职称 1select * from teacher where depart = '计算机系' and prof not in (select prof from teacher where depart = '电子工程系'); 最后将俩个查询结果联合起来，就得到我们想要的结果 union : 求并集 123select * from teacher where depart = '电子工程系' and prof not in (select prof from teacher where depart = '计算机系')unionselect * from teacher where depart = '计算机系' and prof not in (select prof from teacher where depart = '电子工程系'); any表示至少一个，desc降序查询选修编号为‘3-105’课程且成绩高于任意选修编号为‘3-245’同学成绩的同学的cno、sno、degree，并按degree从高到低排序 先查询出‘3-245’课程的所有成绩 1select degree from score where cno = '1-245'; 然后查询出‘3-105’课程成绩，大于‘3-245’课程中的任一成绩，就是符合要求的成绩 any : 任意一个 order by : 排序（升序：asc，降序：desc） 12select cno,sno,degree from score where cno = '3-105' and degree &gt; any(select degree from score where cno = '1-245') order by degree desc; all表示所有查询选修编号为‘3-105’课程且成绩高于所有选修编号为‘3-245’同学成绩的同学的cno、sno、degree这题只需要吧上题稍作修改就可以，把条件‘任一‘换成’所有，全部‘就可以了，而且不需要排序 all : 所有，全部 12select cno,sno,degree from score where cno = '3-105' and degree &gt; all(select degree from score where cno = '1-245'); as取别名查询所有教师和同学的name、sex、birthday as : 取别名 123select sname as name,ssex as sex,sbirthday as birthday from studentunionselect tname,tsex,tbirthday from teacher; 查询所有’女‘教师和’女‘同学的name、sex、birthday123select sname as name,ssex as sex,sbirthday as birthday from student where ssex = '女' unionselect tname,tsex,tbirthday from teacher where tsex = '女'; 复制表数据做条件查询查询成绩比该课程平均成绩低的同学的成绩表。 查询出每门课的平均成绩 1select avg(degree) from score group by cno; 此时相当于两重for循环，当内循环的cno和外循环的cno相等时，将内循环的成绩加入平均成绩的计算 1select * from score a where degree &lt; (select avg(degree) from score b where a.cno = b.cno); not like 模糊查询取反查询student表中不姓’王‘的同学记录 not like : 不像 1select * from student where sname not like '王%'; year函数与now函数查询student表中每个学生的姓名和年龄。 now() : 取当前日期 年龄 = 当前年份-出生年份 1select sname,year(now()) - year(sbirthday) as '年龄' from student; max与min函数查询student表中最大和最小的sbirthday日期值 max() ： 取最大值 min() : 取最小值 1select max(sbirthday) as '最大',min(sbirthday) as '最小' from student; 多字段排序以班号和年龄从大到小的顺序查询student表中的全部记录。1select * from student order by class desc,sbirthday; 按等级查询假设使用如下命令建立了一个grade表： 1234567891011create table grade( low int(3), upp int(3), grade char(1));insert into grade values(90,100,'A');insert into grade values(80,89,'B');insert into grade values(70,79,'C');insert into grade values(60,69,'D');insert into grade values(0,59,'E'); 现查询所有同学的sno、cno和grade列1select sno,cno,grade from score,grade where degree between low and upp;","categories":[{"name":"数据库学习笔记","slug":"数据库学习笔记","permalink":"http://localhost:4000/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://localhost:4000/tags/MySQL/"}]},{"title":"数据库的三大设计范式","slug":"数据库的三大设计范式","date":"2020-02-12T07:26:35.485Z","updated":"2020-02-16T09:08:35.299Z","comments":true,"path":"archives/7c84c2b2.html","link":"","permalink":"http://localhost:4000/archives/7c84c2b2.html","excerpt":"数据库的三大设计范式第一范式– 1NF 数据表中的所有字段都是不可分割的原子值？下表中地址可以继续拆分 12345create table student2( id int primary key, name vaichar(20), address varchar(30)); 字段值还可以继续拆分的，就不满足第一范式下表将地址得更小，更细 12345678create table student2( id int primary key, name vaichar(20), country varchar(30)， privence varchar(30), city varchar(30), detail varchar(30)); 范式，设计的越详细，对于某些实际操作可能更好，但是不一定都是好处","text":"数据库的三大设计范式第一范式– 1NF 数据表中的所有字段都是不可分割的原子值？下表中地址可以继续拆分 12345create table student2( id int primary key, name vaichar(20), address varchar(30)); 字段值还可以继续拆分的，就不满足第一范式下表将地址得更小，更细 12345678create table student2( id int primary key, name vaichar(20), country varchar(30)， privence varchar(30), city varchar(30), detail varchar(30)); 范式，设计的越详细，对于某些实际操作可能更好，但是不一定都是好处 第二范式 必须满足第一范式的前提下，第二范式要求，出主键的每一列都必需完全依赖于主键 如果出现不完全依赖，只可能发生在联合主键的情况下。 订单表 1234567create table myorder( product_id int, customer_id int, product_name varchar(20), customer_name varchar(20), primary key(product_id,customer_id)); 问题？ customer_name 只与 customer_id 有关, product_name 只与 product_id 有关， 除主键以外的其他列，只依赖于主键的部分字段，不满足第二范式 解决办法 拆表 123456789101112131415create table myorder( order_id int primary key, product_id int, customer_id int);create table product( id int primary key, name varchar(20));create table customer( id int primary key, name varchar(20)); 分成三个表之后，就满足了第二范式的设计！！ 第三范式– 3NF 必须先满足第二范式，除开主键列的其他列之间不能有传递依赖关系 如下订单表 123456create table myorder( order_id int primary key, product_id int, customer_id int, customer_phone varchar(15)); 问题： customer_phone 与 customer_id 之间明显存在依赖关系，出现关系冗余 解决办法 拆表 1234567891011create table myorder( order_id int primary key, product_id int, customer_id int);create table customer( id int primary key, name varchar(20), phone varchar(15));","categories":[{"name":"数据库学习笔记","slug":"数据库学习笔记","permalink":"http://localhost:4000/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://localhost:4000/tags/MySQL/"}]},{"title":"mysql建表约束","slug":"mysql建表约束","date":"2020-02-12T06:16:44.411Z","updated":"2020-02-16T09:08:57.140Z","comments":true,"path":"archives/c8a25dc4.html","link":"","permalink":"http://localhost:4000/archives/c8a25dc4.html","excerpt":"mysql建表约束主键约束它能唯一确定一张表中的一条记录，也就是我们通过给某个字段添加约束，就可以使得该字段不重复且不为空。 1234create table user( id int primary key, name varchar(20));","text":"mysql建表约束主键约束它能唯一确定一张表中的一条记录，也就是我们通过给某个字段添加约束，就可以使得该字段不重复且不为空。 1234create table user( id int primary key, name varchar(20)); 联合主键只要联合的主键值加起来不重复就可以 联合主键中任何一个都不能为BULL（空） 123456create table user2( id int, name varchar(20), password varchar(20), premary key(id,name)); 自增约束1234create table user3( id int primary key auto_increment, name carchar(20)); 如果说我们创建表的时候，忘记创建主键约束了？该怎么办？123456create table user4( id int, name varchar(20));alter table user4 add primary key(id); 修改表结构，添加主键1alter table user4 add primary key(id); 如何删除？1alter table user4 drop primary key(id); 使用modify修改字段，修改字段，添加约束1alter table user4 modify id int primary key; 唯一约束约束修饰的字段的值不可以重复 unique(id,name) 表示两个键在一起不重复就行（可以为空） 123456create table user5( id int, name varchar(20));alter table user5 add unique(name); 12345create table user6( id int, name varchar(20), unique(name)); 1234create table user7( id int, name varchar(20) unique); 12345create table user8( id int, name varchar(20), unique(id,name)) 如何删除唯一约束？1alter table user7 drop index name; modify 添加？1alter user7 modify name varchar(20) unique; 总结: 建表的时候就添加约束 可以使用 alter [表] add 。。。 alter [表] modify 。。。 删除 alter [表] drop 。。。 非空约束修饰的字段不能为空 NULL 1234create table user9( id int, name varchar(20) not null); 默认约束就是当我们插入字段值的时候，如果没有传值，就会使用默认值 12345create table user10( if int, name varchar(20), age int default 10); 外键约束– 涉及到两个表：父表，子表 – 主表，副表 – 班级 1234create table classes( id int primary key, name varchar(20)); – 学生表 123456create table students( id int primary key, name varchar(20), class_id int, foreign key(class_id) references classes(id)); 主表classes 中没有的数据值，在副表中，是不可以使用的 主表中的记录被副表引用，是不可以被删除的。","categories":[{"name":"数据库学习笔记","slug":"数据库学习笔记","permalink":"http://localhost:4000/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://localhost:4000/tags/MySQL/"}]},{"title":"mysql初体验","slug":"mysql初体验","date":"2020-02-12T05:07:12.579Z","updated":"2020-02-16T09:08:07.347Z","comments":true,"path":"archives/295082ac.html","link":"","permalink":"http://localhost:4000/archives/295082ac.html","excerpt":"mysql学习笔记– 关系型数据库 一、如何使用终端操作数据库如何登录数据库服务器1mysql -u[用户名] -p[密码] 如何查看数据库服务器中的所有数据1show databases; 如何选中某一个数据库进行操作1use [数据库];","text":"mysql学习笔记– 关系型数据库 一、如何使用终端操作数据库如何登录数据库服务器1mysql -u[用户名] -p[密码] 如何查看数据库服务器中的所有数据1show databases; 如何选中某一个数据库进行操作1use [数据库]; 查询表123select * from [表];select * from [表] where [条件]; 如何退出数据库1exit; 如何在数据库服务器中创建我们的数据库1creat database [数据库]; 如何查看某个数据库中所有的数据表1show tables; 如何创建一个数据表12345678create tables pet( name varchar(20), owner varchar(20), species varchar(20), sex cahr(1), birth date, death date); 如何查看数据表是否创建成功1show tables; 查看创建好的数据表的结构1describe [表]; 如何查看数据表中的记录1select * from [表]; 如何往数据表中插入数据记录1insert into [表] values('[数据]','[数据]',...) mysql常用数据类型有哪些– MySQL支持多种类型，大致可以分为三类： – 数值 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 – 日期/时间 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMPS 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 – 和字符串(字符)类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 WATCHMAKER 0-65535 字节 变长字符串 TINY BLOB 0-255字节 不超过 255 个字符的二进制字符串 TINY TEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUM BLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUM TEXT 0-16 777 215字节 中等长度文本数据 LONG BLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONG TEXT 0-4 294 967 295字节 极大文本数据 数据类型如何选择日期 选择按照格式 数值和字符串按照大小！ 如何删除数据？1delete from [表] where [条件]; 如何修改数据？1update [表] set where [条件]; 总结一下：数据记录常见操作？– 增加 insert – 删除 delete – 修改 update – 查询 select","categories":[{"name":"数据库学习笔记","slug":"数据库学习笔记","permalink":"http://localhost:4000/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://localhost:4000/tags/MySQL/"}]},{"title":"习近平新时代中国特色社会主义思想的主要内容和历史地位","slug":"习近平新时代中国特色社会主义思想的主要内容和历史地位","date":"2019-12-20T11:28:44.030Z","updated":"2020-02-16T09:10:40.834Z","comments":true,"path":"archives/354f6a34.html","link":"","permalink":"http://localhost:4000/archives/354f6a34.html","excerpt":"习近平新时代中国特色社会主义思想的主要内容和历史地位习近平新时代中国特色社会主义思想的主要内容可以概括为“八个明确”和“十四个坚持”：“八个明确”是习近平新时代中国特色社会主义思想的基本内涵： 明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国。 明确新时代中国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕。","text":"习近平新时代中国特色社会主义思想的主要内容和历史地位习近平新时代中国特色社会主义思想的主要内容可以概括为“八个明确”和“十四个坚持”：“八个明确”是习近平新时代中国特色社会主义思想的基本内涵： 明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国。 明确新时代中国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕。 明确中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”，强调坚定“四个自信”。 明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化。 明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家。 明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队。 明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体。 明确中国特色社会主义最本质的特征是中国共产党领导。“党政军民学，东西南北中，党是领导一切的。”中国特色社会主义制度的最大优势是中国共产党领导，党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设在党的建设中的重要地位。 “十四个坚持”则是习近平新时代中国特色社会主义思想基本方略： 坚持党对一切工作的领导。 坚持以人民为中心。 坚持全面深化改革。 坚持新发展理念。 坚持人民当家作主。 坚持全面依法治国。 坚持社会主义核心价值体系。 坚持在发展中保障和改善民生。 坚持人与自然和谐共生。 坚持总体国家安全观。 坚持党对人民军队的绝对领导。 坚持“一国两制”和推进祖国统一。 坚持推动构建人类命运共同体。 坚持全面从严治党。 我们可以将习近平新时代中国特色社会主义思想的历史地位及深远意义概括为三个方面一是习近平新时代中国特色社会主义思想开启了一个历史性飞跃。这就是党的十九大报告所指出的，“久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃”。 二是习近平新时代中国特色社会主义思想引领了一个历史征程。在这一思想指引下，中国特色社会主义进入新时代，开启了建设社会主义现代化强国的新征程，充分展示出中华民族伟大复兴的光明前景。 三是习近平新时代中国特色社会主义思想破解了一个历史课题。在这一思想指引下，“科学社会主义在21世纪的中国焕发出强大生机活力”，成功地开创了社会主义现代化新道路，打破了资本主义现代化道路的“一统天下”，为更多国家启动和实现现代化提供了全新的道路选择，拓展了更大的发展空间，贡献了中国智慧和中国方案，解决了发展中国家如何实现现代化的历史性课题。","categories":[],"tags":[]},{"title":"scanf返回值","slug":"scanf返回值","date":"2019-11-30T13:07:15.000Z","updated":"2019-12-01T11:39:04.550Z","comments":true,"path":"archives/49313.html","link":"","permalink":"http://localhost:4000/archives/49313.html","excerpt":"scanf返回值12345678#include &lt;stdio.h&gt;int main()&#123; int i, j; while(scanf(\"%d%d\", &amp;i, &amp;j) == 2) printf(\"%d\\n\", i + j); return 0;&#125;","text":"scanf返回值12345678#include &lt;stdio.h&gt;int main()&#123; int i, j; while(scanf(\"%d%d\", &amp;i, &amp;j) == 2) printf(\"%d\\n\", i + j); return 0;&#125; while循环的判断条件是scanf(“%d%d”, &amp;i, &amp;j) == 2,第一次见到这种用法，记录下来。 scanf 函数是有返回值的，它的返回值可以分成三种情况 1) 正整数，表示正确输入参数的个数。例如执行 scanf(“%d %d”, &amp;a, &amp;b); 如果用户输入”3 4”，可以正确输入，返回2（正确输入了两个变量）； 如果用户输入”3,4”，可以正确输入a，无法输入b，返回1（正确输入了一个变量）。 2) 0，表示用户的输入不匹配，无法正确输入任何值。如上例，用户如果输入”,3 4”，返回0。 3) EOF，这是在stdio.h里面定义的常量（通常值为-1），表示输入流已经结束。在Windows下，用户按下CTRL+Z（会看到一个^Z字符）再按下回车（可能需要重复2次），就表示输入结束；Linux/Unix下使用CTRL+D表示输入结束。 所以可以使用下面的代码来处理输入：while (scanf(“%s %c %c”, str, &amp;oldchar, &amp;newchar) == 3) /* 或!= EOF , 但前者更好 */{ ; //处理} 为什么前面 scanf 的格式串里面，%s和%c中间需要空格呢？ 那是因为如果没空格的话。。。oldchar输入的就是空格了= =. 顺便说一下，printf的返回值是输出的字符数，例如，printf(“1234”)的返回值是4，而printf(“1234\\n”)的返回值是5。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://localhost:4000/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://localhost:4000/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"二叉树的后序遍历","slug":"二叉树的后序遍历","date":"2019-11-26T13:07:15.000Z","updated":"2019-12-16T11:58:50.657Z","comments":true,"path":"archives/48650.html","link":"","permalink":"http://localhost:4000/archives/48650.html","excerpt":"二叉树的后序遍历给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3]1 2/3 输出: [3,2,1]进阶: 递归算法很简单，你可以通过迭代算法完成吗？","text":"二叉树的后序遍历给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3]1 2/3 输出: [3,2,1]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ C语言递归实现123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */void postor(struct TreeNode *root,int *returnSize,int *res)&#123; if(root) &#123; postor(root-&gt;left,returnSize,res); postor(root-&gt;right,returnSize,res); res[(*returnSize)++] = root-&gt;val; &#125;&#125;/** * Note: The returned array must be malloced, assume caller calls free(). */int* postorderTraversal(struct TreeNode* root, int* returnSize)&#123; int *res = (int*)malloc(sizeof(int) * 1000); *returnSize = 0; if(!root) return res; postor(root,returnSize,res); return res;&#125; 迭代实现解题思路问题： 后序遍历遇到的问题就是到根节点的时候不能直接将节点从 栈 中删除，因为后边还需要回来。 解决办法： 只需要把每个节点 压入栈 两次，然后判断当前节点和栈顶节点是否相同。 相同的话，就意味着是从左子树到的根节点。 不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 res 中。 12345678910111213141516171819202122int* postorderTraversal(struct TreeNode* root, int* returnSize)&#123; int *res = (int*)malloc(sizeof(int) * 100),top = -1; struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 100); *returnSize = 0; if(!root) return NULL; stack[++top] = root; stack[++top] = root; while(top != -1) &#123; root = stack[top--]; if(!root) continue; if(top != -1 &amp;&amp; root == stack[top]) &#123; stack[++top] = root-&gt;right; stack[++top] = root-&gt;right; stack[++top] = root-&gt;left; stack[++top] = root-&gt;left; &#125; else res[(*returnSize)++] = root-&gt;val; &#125; return res;&#125;","categories":[{"name":"DFS","slug":"DFS","permalink":"http://localhost:4000/categories/DFS/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://localhost:4000/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"字符串相加","slug":"字符串相加","date":"2019-11-26T12:26:58.212Z","updated":"2019-11-27T13:21:54.955Z","comments":true,"path":"archives/19353.html","link":"","permalink":"http://localhost:4000/archives/19353.html","excerpt":"字符串相加给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100.num1 和num2 都只包含数字 0-9.num1 和num2 都不包含任何前导零。你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。","text":"字符串相加给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100.num1 和num2 都只包含数字 0-9.num1 和num2 都不包含任何前导零。你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 解题思路：双指针法##字符’0‘~’9‘ 对应ASCII码是48 ~ 57。 从字符串的尾部，从后往前对两个字符串进行相加处理。 需要注意的是：字符串中的数字是属于字符，但字符对应的ASCII是数字，只需要取出字符串中的数字字符，然后减去 ’0‘ 就可以得到该’数字字符‘对应的真正数字。 从后往前先分别对两个字符串的数字字符进行处理后相加，若sum大于10，则标记flag=1（下一位需要加一），sum = sum/10。 123456789101112131415161718192021222324char * addStrings(char * num1, char * num2)&#123; int i = strlen(num1)-1,j = strlen(num2)-1; char *res; int maxlen = (i&gt;j ? i+1:j+1); int k = maxlen+1; int flag = 0; res = (char*)malloc(sizeof(char) * (maxlen+2)); if(!res) return NULL; memset(res, 0, sizeof(char) * (maxlen + 2)); while(i&gt;=0 || j&gt;=0) &#123; int sum = flag; sum += (i &gt;= 0) ? num1[i--] - '0' : 0; sum += (j &gt;= 0) ? num2[j--] - '0' : 0;//此处有个十分惨痛的教训！！！我不小心将num2写成了num1，然后测试代码一直提示数组越界。我愣是被这个小失误卡住了半个多小时！！！！以后一定要小心了，这种细微差别的代码错误实在太难找了！ res[--k] = sum % 10 + '0'; flag = sum / 10; &#125; if(flag) &#123; res[0] = '1'; return res; &#125; else return res + 1;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://localhost:4000/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://localhost:4000/tags/leetcode/"}]},{"title":"杨辉三角II","slug":"杨辉三角II","date":"2019-11-26T12:26:58.119Z","updated":"2019-11-27T13:26:00.228Z","comments":true,"path":"archives/62075.html","link":"","permalink":"http://localhost:4000/archives/62075.html","excerpt":"杨辉三角II给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 3输出: [1,3,3,1]","text":"杨辉三角II给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 3输出: [1,3,3,1] 思路定义一个一维数组保存结果 杨辉三角第n行有n+1个数， 从第一行开始计算杨辉三角的值，保存在一维数组中，后续行的值根据上一行的结果，并将结果覆盖到一维数组。 1234567891011121314int* getRow(int rowIndex, int* returnSize)&#123; *returnSize = rowIndex + 1; int* num = (int*) malloc ((rowIndex + 1) * sizeof(int)); for(int i = 0;i &lt;= rowIndex;i++) &#123; for(int j = i;j &gt;= 0;j--) &#123; if(j == 0 || j == i) num[j] = 1; else num[j] = num[j] + num[j-1]; &#125; &#125; return num;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://localhost:4000/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://localhost:4000/tags/leetcode/"}]},{"title":"杨辉三角","slug":"杨辉三角","date":"2019-11-26T12:26:57.994Z","updated":"2019-11-27T13:25:41.649Z","comments":true,"path":"archives/3601.html","link":"","permalink":"http://localhost:4000/archives/3601.html","excerpt":"杨辉三角给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]]","text":"杨辉三角给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 思路这题可以说是老生常谈了，这题的重点在于对在循环中对二维数组每一行的内存的申请。 用一个二维数组来保存计算的杨辉三角的计算结果，res[i][j] = res[i-1][j] + res[i-1][j-1]; 12345678910111213141516171819//c语言int** generate(int numRows, int* returnSize, int** returnColumnSizes)&#123; *returnSize = numRows; *returnColumnSizes = (int*)malloc(sizeof(int) * numRows); int **res = (int**)malloc(sizeof(int*) * numRows) ; for(int i=0;i&lt;numRows;i++) &#123; (*returnColumnSizes)[i] = i+1; res[i] = (int*)malloc(sizeof(int) * (i+1)); res[i][0] = 1; res[i][i] = 1; for(int j=1;j&lt;i;j++) &#123; res[i][j] = res[i-1][j-1] + res[i-1][j]; &#125; &#125; return res;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://localhost:4000/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://localhost:4000/tags/leetcode/"}]},{"title":"奇偶排序","slug":"奇偶排序","date":"2019-11-26T12:26:57.879Z","updated":"2019-11-27T13:25:09.272Z","comments":true,"path":"archives/28594.html","link":"","permalink":"http://localhost:4000/archives/28594.html","excerpt":"奇偶排序编写完整的程序。将一个数组中的所有奇数移到偶数之前，要求奇偶内部有序。 输入说明：整数数组； 输出说明：整数数组，奇数移到偶数之前且奇偶部分分别有序 输入样例：4 5 1 6 9 8 输出样例：1 5 9 4 6 8","text":"奇偶排序编写完整的程序。将一个数组中的所有奇数移到偶数之前，要求奇偶内部有序。 输入说明：整数数组； 输出说明：整数数组，奇数移到偶数之前且奇偶部分分别有序 输入样例：4 5 1 6 9 8 输出样例：1 5 9 4 6 8 解题思路：双指针法定义两个指针i,j。i指向数组的首元素，j指向数组的最后一个元素。 一次遍历即可完成奇偶交换 1、如果当前a[i]是奇数，则无需交换，i后移，i++。 2、如果当前a[i]是偶数，a[j]是奇数，则交换两数位置，然后指针i后移，i++，指针j前移，j–。 3、如果当前a[i]是偶数，a[j]也是偶数，则j自减1，j–。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//c语言实现#include&lt;stdio.h&gt;void sort(int *a,int len)&#123; int i,j = len-1; int flag; while(i != j) &#123; if(a[i] % 2 == 1) i++; else &#123; if(a[j] % 2 != 0) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; a++; &#125; j--; &#125; &#125; flag = i; for(i=0;i&lt;flag;i++) &#123; for(j=i;j&lt;flag;j++) &#123; if(a[i] &lt; a[j]) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; &#125; for(i=flag;i&lt;len -1;i++) &#123; for(j=i;j&lt;len - 1;j++) &#123; if(a[i] &lt; a[j]) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; &#125; &#125; void main()&#123; int a[5],n,i; printf(\"请输入一个长度为10的数组：\"); for(i=0;i&lt;5;i++) &#123; printf(\"\\n请输入第%d个数：\",i+1); scanf(\"%d\",&amp;a[i]); &#125; for(i=0;i&lt;5;i++) printf(\"%d \",a[i]); sort(a,5); for(i=0;i&lt;5;i++) printf(\"%d \",a[i]);&#125;","categories":[{"name":"试题","slug":"试题","permalink":"http://localhost:4000/categories/%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"试题","slug":"试题","permalink":"http://localhost:4000/tags/%E8%AF%95%E9%A2%98/"}]},{"title":"分割平衡字符串","slug":"分割平衡字符串","date":"2019-11-26T12:26:57.769Z","updated":"2019-11-27T13:26:31.680Z","comments":true,"path":"archives/20288.html","link":"","permalink":"http://localhost:4000/archives/20288.html","excerpt":"分割平衡字符串在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。 给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。 返回可以通过分割得到的平衡字符串的最大数量。 示例 1： 输入：s = “RLRRLLRLRL”输出：4解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。示例 2：","text":"分割平衡字符串在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。 给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。 返回可以通过分割得到的平衡字符串的最大数量。 示例 1： 输入：s = “RLRRLLRLRL”输出：4解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。示例 2： 输入：s = “RLLLLRRRLR”输出：3解释：s 可以分割为 “RL”, “LLLRRR”, “LR”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。示例 3： 输入：s = “LLLLRRRR”输出：1解释：s 只能保持原样 “LLLLRRRR”. 提示： 1 &lt;= s.length &lt;= 1000s[i] = ‘L’ 或 ‘R’ 思路利用的栈的思想对字符串进行遍历 1234567891011121314//c语言int balancedStringSplit(char * s)&#123; int ans = 0,temp = 0; for(;*s;s++) &#123; if(*s == 'L') &#123; temp += 1; &#125; else temp -= 1; if(temp == 0) ans += 1; &#125; return ans;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://localhost:4000/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://localhost:4000/tags/leetcode/"}]},{"title":"strstr函数的实现","slug":"strstr函数的实现","date":"2019-11-26T12:26:57.719Z","updated":"2019-11-27T13:28:06.532Z","comments":true,"path":"archives/40496.html","link":"","permalink":"http://localhost:4000/archives/40496.html","excerpt":"strstr函数的实现编写完整的程序。采用顺序存储方式存储串，计算一个子串在字符串中首次出现的位置，输出这个下标。输入说明：字符串ms 字符串zs 输出说明：zs在ms中首次出现下标 输入样例：baadefaadcb aadc 输出样例：6","text":"strstr函数的实现编写完整的程序。采用顺序存储方式存储串，计算一个子串在字符串中首次出现的位置，输出这个下标。输入说明：字符串ms 字符串zs 输出说明：zs在ms中首次出现下标 输入样例：baadefaadcb aadc 输出样例：6 方法一：两层循环，暴力查找，这种算法效率较低，在极端情况下算法的时间复杂度会极高。高效算法请看法二,KMP算法。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int mystrstr(const char *haystack, const char *needle) &#123; const char *p1; const char *p2; const char *p1_advance = haystack; for (p2 = &amp;needle[1]; *p2; ++p2) &#123; p1_advance++; // advance p1_advance M-1 times &#125; for (p1 = haystack; *p1_advance; p1_advance++) &#123; char *p1_old = (char*) p1; p2 = needle; while (*p1 &amp;&amp; *p2 &amp;&amp; *p1 == *p2) &#123; p1++; p2++; &#125; if (!*p2) return p1 - haystack - 1; p1 = p1_old + 1; &#125; return -1;&#125;int main()&#123; char S[1000],T[100]; int i,j; printf(\"请输入主串和子串（请用空格将主串和子串分开）：\\n\"); scanf(\"%s%s\",S,T); printf(\"%d\",mystrstr(S,T));&#125; ###方法二 1//KMP算法暂时还没有搞懂，等搞明白了在写吧23333","categories":[{"name":"字符串","slug":"字符串","permalink":"http://localhost:4000/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"试题","slug":"试题","permalink":"http://localhost:4000/tags/%E8%AF%95%E9%A2%98/"}]},{"title":"#输出三数中的最大（小）值","slug":"#输出三数中的最大（小）值","date":"2019-11-26T12:26:57.679Z","updated":"2019-11-27T13:27:27.278Z","comments":true,"path":"archives/57731.html","link":"","permalink":"http://localhost:4000/archives/57731.html","excerpt":"#输出三数中的最大（小）值 ### 编写完整的程序。输入三个数，输出其中的最大数，最小数。 输入说明：两个整数N1 N2 N3； 输出说明：最大数 最小数 输入样例：5 4 9 输出样例：9 4","text":"#输出三数中的最大（小）值 ### 编写完整的程序。输入三个数，输出其中的最大数，最小数。 输入说明：两个整数N1 N2 N3； 输出说明：最大数 最小数 输入样例：5 4 9 输出样例：9 4 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;void print_max(int a,int b,int c)&#123; if(a&gt;b) &#123; if(a&gt;c) printf(\"\\n最大数：%d\",a); else printf(\"\\n最大数：%d\",c); &#125; else &#123; if(b&gt;c) printf(\"\\n最大数：%d\",b); else printf(\"\\n最大数：%d\",c); &#125;&#125;void print_min(int a,int b,int c)&#123; if(a&lt;b) &#123; if(a&lt;c) printf(\"\\n最小数：%d\",a); else printf(\"\\n最小数：%d\",c); &#125; else &#123; if(b&lt;c) printf(\"\\n最小数：%d\",b); else printf(\"\\n最小数：%d\",c); &#125;&#125;void main()&#123; int a,b,c; printf(\"请输入三个整数（请用空格将每个数分隔开）：\"); scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); print_min(a,b,c); print_max(a,b,c);&#125;","categories":[{"name":"试题","slug":"试题","permalink":"http://localhost:4000/categories/%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"试题","slug":"试题","permalink":"http://localhost:4000/tags/%E8%AF%95%E9%A2%98/"}]},{"title":"#输出两数之差（和）","slug":"#输出两数之差（和）","date":"2019-11-26T12:26:57.640Z","updated":"2019-11-27T13:26:57.454Z","comments":true,"path":"archives/47102.html","link":"","permalink":"http://localhost:4000/archives/47102.html","excerpt":"#输出两数之差（和） ###编写完整的程序。输入两个数，输出他们的和与差。 输入说明：两个整数N1，N2； 输出说明：两个整数的和与差 输入样例：12 7 输出样例：19 5","text":"#输出两数之差（和） ###编写完整的程序。输入两个数，输出他们的和与差。 输入说明：两个整数N1，N2； 输出说明：两个整数的和与差 输入样例：12 7 输出样例：19 5 1234567891011#include&lt;stdio.h&gt;#include&lt;math.h&gt;void main()&#123; int a,b; printf(\"请输入两个整数N1和N2（请用空格将N1和N2分隔开）：\"); scanf(\"%d%d\",&amp;a,&amp;b); printf(\"两数之和为%d，两数之差为%d\",a+b,abs(a-b));&#125;","categories":[{"name":"试题","slug":"试题","permalink":"http://localhost:4000/categories/%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"试题","slug":"试题","permalink":"http://localhost:4000/tags/%E8%AF%95%E9%A2%98/"}]},{"title":"二叉树的中序遍历","slug":"二叉树的中序遍历","date":"2019-11-25T13:07:15.000Z","updated":"2019-11-27T13:28:32.967Z","comments":true,"path":"archives/47236.html","link":"","permalink":"http://localhost:4000/archives/47236.html","excerpt":"二叉树的中序遍历给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [1,3,2]进阶: 递归算法很简单，你可以通过迭代算法完成吗？","text":"二叉树的中序遍历给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [1,3,2]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 递归实现：12345678910111213141516171819202122232425void inorder(struct TreeNode* root, int* returnSize,int *arr)&#123; if(root) &#123; if(root-&gt;left) &#123; inorder(root-&gt;left,returnSize,arr); &#125; arr[(*returnSize)++] = root-&gt;val; if(root-&gt;right) &#123; inorder(root-&gt;right,returnSize,arr); &#125; &#125;&#125;/** * Note: The returned array must be malloced, assume caller calls free(). */int* inorderTraversal(struct TreeNode* root, int* returnSize)&#123; int *arr = (int*)malloc(sizeof(int) * 1000); *returnSize = 0; inorder(root,returnSize,arr); return arr;&#125; 迭代实现：（后续更新。。。）思路：1）while循环向左深入，将经历的节点依次添加到栈中，直到找到树的最左节点。 2）然后从栈中依次返回节点进行遍历，并将节点值添加到结果集（res）。 3）查询当前节点有无右节点，如果有则查询该节点有无左子树，如果有则继续深入该左子树，将经历的节点依次添加到栈中，直到找到最左节点（即重复第一步） （ps：树的迭代算法真难搞。。参考别人的代码，代例子一步步算，才看懂。） 123456789101112131415161718192021222324252627int* inorderTraversal(struct TreeNode* root, int* returnSize)&#123; int *res = (int*)malloc(sizeof(int) * 100); struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 100); int top = -1; *returnSize = 0; if(!root) return NULL; stack[++top] = root; while(root-&gt;left) &#123; stack[++top] = root-&gt;left; root = root-&gt;left; &#125; while(top != -1) &#123; root = stack[top--]; res[(*returnSize)++] = root-&gt;val; root = root-&gt;right; while(root) &#123; stack[++top] = root; root = root-&gt;left; &#125; &#125; return res;&#125;","categories":[{"name":"DFS","slug":"DFS","permalink":"http://localhost:4000/categories/DFS/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://localhost:4000/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"tip","slug":"tip","date":"2019-11-24T13:07:15.000Z","updated":"2019-12-01T11:41:24.479Z","comments":true,"path":"archives/46650.html","link":"","permalink":"http://localhost:4000/archives/46650.html","excerpt":"printf+指针的特殊用法偶然发现一个有趣的现象，记录在博客里 以下是测试代码 12345678#include&lt;stdio.h&gt;void main()&#123; int a[] = &#123;1,3,6&#125;; int *p = a; printf(\"%d %d %d\",*p,*(p++),*(p++)); &#125;","text":"printf+指针的特殊用法偶然发现一个有趣的现象，记录在博客里 以下是测试代码 12345678#include&lt;stdio.h&gt;void main()&#123; int a[] = &#123;1,3,6&#125;; int *p = a; printf(\"%d %d %d\",*p,*(p++),*(p++)); &#125; 然后发现printf打印出来的结果并不是按数组顺序打印出 1 3 6， 而是倒序打印出来的6 3 1 原理不知道是什么，先记录下来，留待解答。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://localhost:4000/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://localhost:4000/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"二叉树的先序遍历","slug":"二叉树的先序遍历","date":"2019-11-24T13:07:15.000Z","updated":"2019-11-27T13:28:22.884Z","comments":true,"path":"archives/44460.html","link":"","permalink":"http://localhost:4000/archives/44460.html","excerpt":"二叉树的先序遍历给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？","text":"二叉树的先序遍历给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 递归实现12345678910111213141516171819202122void preorder(struct TreeNode *root,int *arr,int *n)&#123; struct TreeNode *p = root; if(p) &#123; arr[(*n)++] = p-&gt;val; preorder(p-&gt;left,arr,n); preorder(p-&gt;right,arr,n); &#125;&#125;/** * Note: The returned array must be malloced, assume caller calls free(). */int* preorderTraversal(struct TreeNode* root, int* returnSize)&#123; int *arr = (int*)malloc(sizeof(int) * 1000); *returnSize = 0; preorder(root,arr,returnSize); return arr; &#125; 迭代实现：（2019.11.23 更）使用数组模拟栈的进栈出站操作。 在循环中，从栈顶提取节点，删除当前栈顶的节点，top指针下移； 先让右子树进栈，再让左子树进栈； 要注意的是，在进栈的时候，左右结点要反向插入 ，这样在从栈顶元素读取节点的时候就会先进入左节点，后进入右节点； 123456789101112131415161718192021int* preorderTraversal(struct TreeNode* root, int* returnSize)&#123; int* res = (int*)malloc(sizeof(int) * 1000),top = -1; struct TreeNode* stack[1000]; *returnSize = 0; if(!root) return NULL; stack[++top] = root; while(top != -1) &#123; root = stack[top--]; res[(*returnSize)++] = root-&gt;val; if(root-&gt;right) &#123; stack[++top] = root-&gt;right; &#125; if(root-&gt;left) &#123; stack[++top] = root-&gt;left; &#125; &#125; return res;&#125;","categories":[{"name":"DFS","slug":"DFS","permalink":"http://localhost:4000/categories/DFS/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://localhost:4000/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"关于malloc的内存分配","slug":"关于malloc的内存分配","date":"2019-11-24T13:07:15.000Z","updated":"2019-12-01T11:42:48.794Z","comments":true,"path":"archives/37683.html","link":"","permalink":"http://localhost:4000/archives/37683.html","excerpt":"关于malloc的内存分配​ 今天在群里聊到了关于C语言的数组内存分配的问题。这涉及到了堆栈的知识，对知识面是一个不小的扩充。 ​ 问题的引出： 1假如现在有两个连续的内存块a和b，a的大小是10，b的大小是6。如果这时需要申请一个内存大小为12的数组，能否申请成功？","text":"关于malloc的内存分配​ 今天在群里聊到了关于C语言的数组内存分配的问题。这涉及到了堆栈的知识，对知识面是一个不小的扩充。 ​ 问题的引出： 1假如现在有两个连续的内存块a和b，a的大小是10，b的大小是6。如果这时需要申请一个内存大小为12的数组，能否申请成功？ C语言的数组的内存空间一定是连续的吗？ 按照我之前的想法，我认为这是可以申请成功的，malloc在给数组分配内存时会将内存块a和b连接起来共同作为这个数组的内存空间；（但事实是，我的想法是错误的） 我之前一直认为： malloc 寻找内存，如果找不到到一个&gt;= 需求的连续内存空间，malloc就会将多个不连续的小内存块连接起来使用 经过和群里的大佬的一番讨论，对malloc的内存分配机制有了更深入的了解： ​ malloc 是用链表实现的 ​ 内存以堆组成 ​ 将可用的内存块连接为一个长长的列表的所谓空闲链表 ​ 调用的时候就沿着链表找 最后在一篇博文中找到了问题的答案： 原文链接： https://blog.csdn.net/Fan0920/article/details/80999850问题的引出：堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内存块中找到一些满足要求的合适块。所以可能让人觉得只要有很多不连续的零散的小区域，只要总数达到申请的内存块，就可以分配。 但事实上是不行的，这又让人觉得是不是零散的内存块不能连接成一个大的空间，而必须要一整块连续的内存空间才能申请成功呢。 答案： 申请和释放许多小的块可能会产生如下状态：在已用块之间存在很多小的空闲块。进而申请大块内存失败，虽然空闲块的总和足够，但是空闲的小块是零散的，不能满足申请的大小。这叫做“堆碎片”。 当旁边有空闲块的已用块被释放时，新的空闲块会与相连的空闲块合并成一个大的空闲块，这样就可以有效的减少”堆碎片”的产生。 堆分配的空间在逻辑地址上是连续的，但在物理地址上是不连续的（因为采用了页式内存管理,windows下有段机制、分页机制），如果逻辑地址空间上已经没有一段连续且足够大的空间，则分配内存失败。 堆栈的知识扩充：原文地址： https://blog.csdn.net/jin13277480598/article/details/54406980","categories":[{"name":"堆栈","slug":"堆栈","permalink":"http://localhost:4000/categories/%E5%A0%86%E6%A0%88/"},{"name":"随笔","slug":"堆栈/随笔","permalink":"http://localhost:4000/categories/%E5%A0%86%E6%A0%88/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://localhost:4000/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"梦到一个卖花的两手空空跟我说 人要先感到幸福 才能看到玫瑰","slug":"梦到一个卖花的两手空空跟我说 人要先感到幸福 才能看到玫瑰","date":"2019-11-11T12:44:59.561Z","updated":"2019-11-27T13:29:19.486Z","comments":true,"path":"archives/3375.html","link":"","permalink":"http://localhost:4000/archives/3375.html","excerpt":"","text":"梦到一个卖花的两手空空跟我说 人要先感到幸福 才能看到玫瑰","categories":[],"tags":[]},{"title":"HEXO+GitHub搭建个人博客","slug":"HEXO+GitHub搭建个人博客","date":"2019-11-04T12:52:00.857Z","updated":"2019-11-27T12:29:05.220Z","comments":true,"path":"archives/24183.html","link":"","permalink":"http://localhost:4000/archives/24183.html","excerpt":"HEXO+GitHub搭建个人博客原文地址： https://www.cnblogs.com/shwee/p/11421156.html # 第一部分 搭建hexo的初级搭建还有部署到github page上，以及个人域名的绑定。 Hexo搭建步骤 1.安装Git 2.安装Node.js 3.安装Hexo 4.GitHub创建个人仓库 5.生成SSH添加到GitHub 6.将hexo部署到GitHub 7.设置个人域名 8.发布文章","text":"HEXO+GitHub搭建个人博客原文地址： https://www.cnblogs.com/shwee/p/11421156.html # 第一部分 搭建hexo的初级搭建还有部署到github page上，以及个人域名的绑定。 Hexo搭建步骤 1.安装Git 2.安装Node.js 3.安装Hexo 4.GitHub创建个人仓库 5.生成SSH添加到GitHub 6.将hexo部署到GitHub 7.设置个人域名 8.发布文章 ## 1. 安装Git为了把本地的网页文件上传到github上面去，需要用到工具———Git[下载地址]。Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git非常强大，建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以看一下。Git教程 windows：到git官网上下载.exe文件,Download git,安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。 顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码 1sudo apt-get install git 安装完成后在命令提示符中输入git --version来查看一下版本验证是否安装成功。 ## 2. 安装nodejsHexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。 windows：下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。 linux：命令行安装： 12sudo apt-get install nodejssudo apt-get install npm 不过不推荐命令行安装，有时候有问题，建议直接到官网去下载编译好的压缩文件。然后解压到你指定的文件夹即可，比如我解压到我系统的/home/shw/MySoftwares目录下了。 注意本压缩包是.tar.xz格式的，需要两次解压 配置一下环境变量 1sudo vim /etc/profile 复制下面两行到刚打开的profile文件最底部(注意node的安装地址/home/shw/MySoftwares/node-v12.8.0-linux-x64换成自己的)： 12export NODE_HOME=/home/shw/MySoftwares/node-v12.8.0-linux-x64export PATH=$PATH:$NODE_HOME/bin 保存后退出，再执行下面命令将环境变量生效： 1source /etc/profile 将目录软链接到全局环境下（命令后面的/usr/local/bin/node是固定的） 12sudo ln -s /home/shw/MySoftwares/node-v12.8.0-linux-x64/node /usr/local/bin/nodesudo ln -s /home/shw/MySoftwares/node-v12.8.0-linux-x64/npm /usr/local/bin/npm 这样安装好了以后使用npm安装的包(比如：ionic serve)，使用包的命令时可能会提示找不到命令，没关系，在用户目录下终端执行下面命令(固定写法)： 1echo -e &quot;export PATH=$(npm prefix -g)/bin:$PATH&quot; &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc 这样我们在所有用户下，都可以使用npm，也可以使用npm安装的包的命令。成功的将nodejs安装并配置到全局环境下。 安装完后，打开命令行终端，输入: 12node -vnpm -v 检查一下有没有安装成功 添加国内镜像源如果没有梯子的话，可以使用阿里的国内镜像进行加速。 1npm config set registry https://registry.npm.taobao.org ## 3. 安装Hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 比如我的博客文件都存放在D:\\Study\\MyBlog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，无视它就行。 1npm install -g hexo-cli 安装完后输入hexo -v验证是否安装成功。 至此hexo就安装完了。 接下来初始化一下hexo,即初始化我们的网站，输入hexo init初始化文件夹 1hexo init MyBlog 这个MyBlog可以自己取什么名字都行，然后，接着输入npm install安装必备的组件。 12cd MyBlog //进入这个MyBlog文件夹npm install 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器， 12hexo ghexo server(或者简写:hexo s）) 然后浏览器打开http://localhost:4000/，就可以在本地预览博客啦！按ctrl+c关闭本地服务器。 ## 4. 注册Github账号创建个人仓库接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。 打开https://github.com/，新建一个项目仓库`New repository， 输入自己的项目名字，后面一定要加.github.io后缀，README`初始化也要勾上。 要创建一个和你用户名相同的仓库，后面加.http://github.io，只有这样，将来要部署到`GitHub page的时候，才会被识别，也就是http://xxxx.github.io，其中xxx就是你注册GitHub`的用户名。例如我的：http://shw2018.github.io ## 5. 生成SSH添加到GitHub生成SSH添加到GitHub，连接Github与本地。右键打开git bash，然后输入下面命令： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。例如我的： 12git config --global user.name &quot;shw2018&quot;git config --global user.email &quot;hwsun@std.uestc.edu.cn&quot; 可以用以下两条，检查一下你有没有输对 12git config user.namegit config user.email 然后创建SSH,一路回车 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 1ssh-keygen -t rsa -C &quot;youremail&quot; 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。或者git bash中输入 1cat ~/.ssh/id_rsa.pub 将输出的内容复制到框中，点击确定保存。 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。 在git bash输入ssh -T git@github.com。 ## 6. 将hexo部署到GitHub这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。 修改最后一行的配置： 1234deploy: type: git repository: https://github.com/shw2018/shw2018.github.io branch: master repository修改为你自己的github项目地址即可，就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 1npm install hexo-deployer-git --save 然后 123hexo cleanhexo generatehexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。 hexo generate顾名思义，生成静态文章，可以用 hexo g缩写 ，hexo deploy部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！","categories":[],"tags":[]}]}